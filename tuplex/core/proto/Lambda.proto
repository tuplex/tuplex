syntax = "proto3";
package tuplex.messages;

enum FileFormat {
    FF_UNKNOWN = 0;
    FF_TUPLEX = 1;
    FF_CSV = 2;
    FF_TEXT = 3;
}

enum EndPointMode {
    EPM_UNKNOWN = 0;
    EPM_MEMORY = 1;
    EPM_FILE = 2;
    EPM_HASHTABLE = 3;
}

enum MessageType {
    MT_UNKNOWN = 0;
    MT_WARMUP = 1;
    MT_TRANSFORM = 2;
}

enum SerializationFormat {
    SF_JSON = 0;
    SF_CEREAL = 1;
}

message CodePath {
    bytes irBitCode = 1;
    string initStageFuncName = 2;
    string releaseStageFuncName = 3;
    string funcStageName = 4;
    string funcProcessRowName = 5;
    string writeFileCallbackName = 6;
    string writeMemoryCallbackName = 7;
    string writeHashCallbackName = 8;
    string writeExceptionCallbackName = 9;
    string writeAggregateCallbackName = 10;

    string aggregateInitFuncName = 11;
    string aggregateCombineFuncName = 12;
    string aggregateAggregateFuncName = 13;
}

message TransformStage {
    bytes bitcode = 1;
    repeated string inputColumns = 2;
    repeated string outputColumns = 3;

    string readSchema = 4;
    string inputSchema = 5;
    string outputSchema = 6;
    string normalCaseInputSchema = 7;
    string normalCaseOutputSchema = 8;
    repeated uint32 normalCaseInputColumnsToKeep = 9;
    repeated uint32 generalCaseInputColumnsToKeep = 10;
    uint32 outputDataSetID = 11;
    uint32 inputNodeID = 12;
    EndPointMode inputMode = 13;
    EndPointMode outputMode = 14;

    string outputURI = 15;
    FileFormat inputFormat = 16;
    FileFormat outputFormat = 17;
    bool persistSeparateCases = 18;
    bool updateInputExceptions = 19;

    // the code paths (fast / slow)
    optional CodePath fastPath = 20;
    optional CodePath slowPath = 21;

    // bytes holding serialized stage, ready for hyper-specialization.
    optional bytes serializedStage = 22;
    optional SerializationFormat stageSerializationMode = 23;

    uint32 stageNumber = 24;
    uint32 numColumns = 25;
    string pycode = 26;
    string pyPipelineName = 27;
    string pyaggcode = 28;
    string pyaggname = 29;

    // file input + output params as dict
    map<string, string> inputParameters = 30;
    map<string, string> outputParameters = 31;

    // how many lambdas should each Lambda invoke? Recursive, i.e. {1, 1, 1} means the first Lambda invokes another
    // lambda, that again another etc. The total wait time thereby is baseDelay * depth
    repeated uint32 invocationCount = 32;
}

message WorkerSettings {
    optional uint32 numThreads = 1;
    optional uint32 normalBufferSize = 2;
    optional uint32 exceptionBufferSize = 3;
    optional uint32 hashBufferSize = 4;
    optional string spillRootURI = 5;
    optional uint32 runTimeMemoryPerThread = 6;
    optional uint32 runTimeMemoryPerThreadBlockSize = 7;
    optional bool allowNumericTypeUnification = 8;
    optional bool useInterpreterOnly = 9;
    optional float normalCaseThreshold = 10;
}

message WarmupMessage {
    // how many lambdas should each Lambda invoke? Recursive, i.e. {1, 1, 1} means the first Lambda invokes another
    // lambda, that again another etc. The total wait time thereby is baseDelay * depth
    repeated uint32 invocationCount = 1;
    uint32 baseDelayInMs = 2;
    uint32 timeOutInMs = 3;
}

// a simple message for a resource that may be send along an invocation request
message Resource {
    string id = 1;
    uint32 type = 2;
    bytes payload = 3;
}

message InvocationRequest {
    repeated string inputURIS = 1;
    repeated uint64 inputSizes = 2;
    string baseOutputURI = 3; // final output uri or base URI to form parts
    optional uint32 partNoOffset = 4; // this is where to start the parts. important when recursive invocations are used

    MessageType type = 5;
    WorkerSettings settings = 6;

    // optional resources attached with this message
    repeated Resource resources = 7;

    optional TransformStage stage = 8;
    optional WarmupMessage warmup = 9;
    bool verboseLogging = 10;
}


// info about a running container, cf. ContainerInfo struct
message ContainerInfo {
    bool reused = 1;
    string requestId = 2;
    string uuid = 3;
    uint32 msRemaining = 4;
    uint32 requestsServed = 5;
    uint64 start = 6;
    uint64 deadline = 7;
}

// info about a single request , cf. Request Info struct
message RequestInfo {
    string requestId = 1;
    string containerId = 2;
    double durationInMs = 3;
    uint32 billedDurationInMs = 4;
    uint32 memorySizeInMb = 5;
    uint32 maxMemoryUsedInMb = 6;

    uint64 tsRequestStart = 7; // UTC timestamp when request was invoked
    uint64 tsRequestEnd = 8; // UTC timestamp when request returned

    // in case of failure, these fields here are filled.
    uint32 returnCode = 9;
    string errorMessage = 10;
}

// statistics about how input rows were processed.
message CodePathStats {
    uint64 normal = 1;
    uint64 general = 2;
    uint64 interpreter = 3;
    uint64 unresolved = 4;
}

message InvocationResponse {
    enum Status {
        SUCCESS = 0;
        ERROR = 1;
    }
    Status status = 1;
    string errorMessage = 2;
    MessageType type = 3;

    repeated string inputURIS = 4;
    repeated string outputURIs = 5;

    uint64 numRowsWritten = 6;
    uint64 numExceptions = 7;
    uint64 numBytesWritten = 8;

    map<uint64, uint64> exceptionCounts = 9;
    CodePathStats rowStats = 10;

    ContainerInfo container = 11;
    repeated ContainerInfo invokedContainers = 12;
    repeated RequestInfo invokedRequests = 13;

    // messages may contain already result data, given in form of a resource
    repeated Resource resources = 14;

    // stats
    double awsInitTime = 15;
    double taskExecutionTime = 16;
    map<string, uint64> s3Stats = 17;
    map<string, double> breakdownTimes = 18;
}
